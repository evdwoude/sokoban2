Next:

    Create a return path for 'no new move found'.

    Double check the below and wrap up:
        Keep Johnny up to date while walking the move tree?
        Pro: Know where Johnny is for extend_depth()
        Con: Does not match with take_back. . .
            Consider: Johnny a paramter to find_or_add_position(), instead of taking johnny from game_data.

    Make bingo stop and try a few primitive real setups.

    Try with more corner cases, especially w.r.t. changed reaches

    Test Backward cases (Similar, with tossed boxes and targets?)

    Test nogos with:
            #####
        ##### . #
        #       #
        ####    #
           #    #
           ######

    Revise this todo list

    Double check make dependencies


    Next:

    Create list of start posiitons for backward search.
    Remove dead backward seard trees from that list
        Needs 'no new move found'.

    Create stop condifiotn (program stops) when 'no new move found'. (Forward and backward differ here.)

    Create Got_it()
        print.
        stop.



    Consider to split:
                        make_move(..., just_move/take_back, ...);
                 into:
                        make_move(...);  and  take_back(...);



    Keep track of distance, and replace existing moves by moves on the same level but with shorter distance, considering
    a setup a simple as:

            #####
        #####   #
        #.X.OX  #
        #########       (setup-test 27)



    Prune dead branches.
    This is similar to pruning dead backward trees, but more difficult. It requires tracking of "no new moves found" at
    the move node level, rather than at the move root level.



    Document headers for functions in position.c. Might decrease heavy comments.

    Use more exit() calls and clean up code.
        At least do it for allocate_memory()

    Rename bingo back to gotcha.

    Todo:
        Document latest changes
        Test for the maximum value of the index before returning a new tree memblock.
        Double check the dependencies.

    Return values of functions:
            A function primarily returns the intrinsic result.
            If an error conditon is a potential outcome:
                - Embed the errror condition in the function result
                - Where ever that is not feasible, use a sepate return variable for the error.



    Double check the conditions for new_hardnogos in the linescanner.

    Document why this impl uses indexed arrays and not pointers. (Jeopardising type safety.)

    Change and document file structure:
        - Create blockers.c
            Move define_hardnogos there.

    Print large setup: change to 3-digit numbers; similar to medium setup

Later:
    Find blockers in run time.
        Start with doubles:

            #X      Or:     #X
            #X              X#

        Next is squares.

            XX      Or:     #X
            XX              XX

    Compile with optimisation for speed.

    Malloc the playing grounds (instead of static 50*50.) ?


